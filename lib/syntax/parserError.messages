prog: VAR
##
## Ends in an error in state: 0.
##
## prog' -> . prog [ # ]
##
## The known suffix of the stack is as follows:
##
##

[E000]Invalid program.

prog: WHILE VAR
##
## Ends in an error in state: 1.
##
## expr -> WHILE . expr DO expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE
##

[E001]Expecting an expression followed by DO

prog: MINUS VAR
##
## Ends in an error in state: 4.
##
## arith -> MINUS . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## MINUS
##

[E002]Expecting an arithmetic expression

prog: LPAREN VAR
##
## Ends in an error in state: 5.
##
## expr -> LPAREN . RPAREN [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## expr -> LPAREN . exprs RPAREN [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

[E003]Unclosed LPAREN, Expecting expressions or RPAREN
Note: () -- a unit value. (e1; e2; ...) -- a seq.

prog: LET WHILE
##
## Ends in an error in state: 8.
##
## decs -> decs . tydec [ VAR TYPE IN FUNCTION ]
## decs -> decs . vardec [ VAR TYPE IN FUNCTION ]
## decs -> decs . fundec [ VAR TYPE IN FUNCTION ]
## letexp -> LET decs . IN exprs END [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## LET decs
##

[E004]Let-expression ended abruptly.
Note: variable bindings and expressions are separated by IN.
Note: A valid letexp looks like
`let var x := 1 in println x end`

prog: LET VAR WHILE
##
## Ends in an error in state: 9.
##
## vardec -> VAR . ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR . ID COLON ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR
##

[E005]Variable definition ended abruptly. Expecting ID ASSIGN followed by an expression.
Note: A valid vardec looks like
(between LET and IN) `...var id := 1...(more decs)`
                             ~~~~^ (ID ASSIGN)

prog: LET VAR ID WHILE
##
## Ends in an error in state: 10.
##
## vardec -> VAR ID . ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID . COLON ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID
##

[E006]Variable definition ended abruptly. 
Expecting (-optionally type annotation and-) ASSIGN followed by an expression.
Note: A valid vardec looks like
(between LET and IN) `...var id := 1...(more decs)` -- inferred type
(between LET and IN) `...var id : Int := 1...(more decs)`
                                ~~~~^ (explicit type annotation)



prog: LET VAR ID COLON WHILE
##
## Ends in an error in state: 11.
##
## vardec -> VAR ID COLON . ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON
##

[E007]Variable definition ended abruptly. Expecting a type.
Note: A valid vardec looks like
(between LET and IN) `...var id : Int := 1...(more decs)`


prog: LET VAR ID COLON ID WHILE
##
## Ends in an error in state: 12.
##
## vardec -> VAR ID COLON ID . ASSIGN expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID
##

[E008]Variable definition ended abruptly. Expecting ASSIGN.
Note: A valid vardec looks like
(between LET and IN) `...var id := 1...(more decs)`


prog: LET VAR ID COLON ID ASSIGN VAR
##
## Ends in an error in state: 13.
##
## vardec -> VAR ID COLON ID ASSIGN . expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN
##

[E009]Variable definition ended abruptly. Expecting a expression (body)
Note: A valid vardec looks like
(between LET and IN) `...var id := cond c e1 e2 ...(more decs)`
                                   ~~~~~~~~~~~^ (body) 

prog: IF VAR
##
## Ends in an error in state: 15.
##
## ite -> IF . expr THEN expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## ite -> IF . expr THEN expr ELSE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF
##

[E010]Malformed if-then-else. Expecting a expression (condition)
Note: A valid ite looks like
`if p x then true else false`
    ~~^ (condition)

prog: ID WHILE
##
## Ends in an error in state: 16.
##
## instOfArr -> ID . LBRACE expr RBRACE OF expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## instOfRec -> ID . LBRACK tdefs RBRACK [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## lvalue -> ID . lvalue_ [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID
##

[E011]Unexpected token after '$0'. An ID constitutes
  ID DOT ID         -- record accessor
  ID [expr]         -- array accessor
  ID [expr] of expr -- array instantiation iff ID is a type
  ID {tdefs}        -- record instantiation iff ID is a type


prog: ID LPAREN VAR
##
## Ends in an error in state: 27.
##
## argvalue -> LPAREN . RPAREN [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## argvalue -> LPAREN . exprc RPAREN [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

[E012]Malformed argument value. Expecting one of the following:
  ()            -- Unit              Note: Add             RPAREN
  (e)           -- an expr           Note: Add expr        RPAREN
  (e1, e2, ...) -- an tuple of exprs Note: Add expr[,expr] RPAREN

prog: FOR WHILE
##
## Ends in an error in state: 20.
##
## expr -> FOR . ID ASSIGN expr TO expr DO expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## FOR
##

[E013]For-loop ended abruptly. Expecting a ID ASSIGN e1 TO e2 (range)
Note: A for-loop looks like
`for i := 0 to 10 do println i`
     ~~~~~~~~~~~^ (range)

prog: FOR ID WHILE
##
## Ends in an error in state: 21.
##
## expr -> FOR ID . ASSIGN expr TO expr DO expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## FOR ID
##

[E014]For-loop ended abruptly. Expecting a ASSIGN.
Note: A for-loop looks like
`for i := 0 to 10 do println i`

prog: FOR ID ASSIGN VAR
##
## Ends in an error in state: 22.
##
## expr -> FOR ID ASSIGN . expr TO expr DO expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN
##

[E015]For-loop ended abruptly. Expecting a expression (loop-body).
Note: A for-loop looks like
`for i := 0 to 10 do println i`
                     ~~~~~~~~^ (loop-body)

prog: ID ASSIGN VAR
##
## Ends in an error in state: 78.
##
## assignment -> lvalue ASSIGN . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN
##

[E016]The RHS of an assignment is an expr.
Note: An assignment looks like `x := e`

prog: ID ASSIGN INT WHILE
##
## Ends in an error in state: 79.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## assignment -> lvalue ASSIGN expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN expr
##

[E017]Unexpected token after '$0'

prog: INT TIMES VAR
##
## Ends in an error in state: 38.
##
## arith -> expr TIMES . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr TIMES
##

[E018]Unexpected token after '$0'. Expecting an arithmetic expression.

prog: INT PLUS VAR
##
## Ends in an error in state: 48.
##
## arith -> expr PLUS . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr PLUS
##

[E019]Unexpected token after '$0'. Expecting an arithmetic expression.

prog: INT PLUS INT WHILE
##
## Ends in an error in state: 49.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr PLUS expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr PLUS expr
##

[E020]Unexpected token after '$0'. Expecting an arithmetic or comparing expression

prog: INT DIVIDE VAR
##
## Ends in an error in state: 50.
##
## arith -> expr DIVIDE . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr DIVIDE
##

[E021]Unexpected token after '$0'. Expecting an arithmetic expression

prog: INT OR VAR
##
## Ends in an error in state: 52.
##
## compare -> expr OR . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr OR
##

[E022]Unexpected token after '$0'. Expecting an expression

prog: INT OR INT WHILE
##
## Ends in an error in state: 53.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr OR expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr OR expr
##

[E023]Unexpected token after '$0'. Expecting an arithmetic or comparing expression

prog: INT NEQ VAR
##
## Ends in an error in state: 54.
##
## compare -> expr NEQ . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr NEQ
##

[E024]Unexpected token after '$0'. Expecting an arithmetic expression

prog: INT NEQ INT WHILE
##
## Ends in an error in state: 55.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr NEQ expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr NEQ expr
##

[E025]Unexpected token after '$0'. Expecting an arithmetic or comparing expression.

prog: INT MINUS VAR
##
## Ends in an error in state: 56.
##
## arith -> expr MINUS . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr MINUS
##

[E026]Unexpected token after '$0'. Expecting an arithmetic expression.

prog: INT MINUS INT WHILE
##
## Ends in an error in state: 57.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr MINUS expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr MINUS expr
##

[E027]Unexpected token after '$0'. Expecting an arithmetic or comparing expression

prog: INT LT VAR
##
## Ends in an error in state: 58.
##
## compare -> expr LT . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr LT
##

[E028]Unexpected token after '$0'. Expecting an comparing expression

prog: INT LT INT WHILE
##
## Ends in an error in state: 59.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr LT expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr LT expr
##

[E029]Unexpected token after '$0'. Expecting an arithmetic or comparing expression.

prog: INT LE VAR
##
## Ends in an error in state: 60.
##
## compare -> expr LE . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr LE
##

[E030]Unexpected token after '$0'. Expecting an comparing expression

prog: INT LE INT WHILE
##
## Ends in an error in state: 61.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr LE expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr LE expr
##

[E031]Unexpected token. Expecting an arithmetic or comparing expression 

prog: INT GT VAR
##
## Ends in an error in state: 62.
##
## compare -> expr GT . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr GT
##

[E032]Unexpected token after '$0'. Expecting an comparing expression

prog: INT GT INT WHILE
##
## Ends in an error in state: 63.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr GT expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr GT expr
##

[E033]Unexpected token after '$0'. Expecting an arithmetic or comparing expression

prog: INT GE VAR
##
## Ends in an error in state: 64.
##
## compare -> expr GE . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr GE
##

[E034]Unexpected token after '$0'. Expecting an comparing expression

prog: INT GE INT WHILE
##
## Ends in an error in state: 65.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr GE expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr GE expr
##

[E035]Unexpected token after '$0'. Expecting an arithmetic or comparing expression.

prog: INT EQ VAR
##
## Ends in an error in state: 66.
##
## compare -> expr EQ . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr EQ
##

[E036]Unexpected token after '$0'. Expecting an comparing expression

prog: INT EQ INT WHILE
##
## Ends in an error in state: 67.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr EQ expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr EQ expr
##

[E037]Unexpected token after '$0'. Expecting an arithmetic or comparing expression

prog: INT AND VAR
##
## Ends in an error in state: 68.
##
## compare -> expr AND . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr AND
##

[E038]Unexpected token after '$0'. Expecting an comparing expression

prog: INT AND INT WHILE
##
## Ends in an error in state: 69.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr AND expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr AND expr
##

[E039]Unexpected token after '$0'. Expecting an arithmetic or comparing expression.

prog: FOR ID ASSIGN INT VAR
##
## Ends in an error in state: 81.
##
## arith -> expr . PLUS expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . MINUS expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . TIMES expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . DIVIDE expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . EQ expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . NEQ expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . GT expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . LT expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . GE expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . LE expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . AND expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . OR expr [ TO TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## expr -> FOR ID ASSIGN expr . TO expr DO expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr
##

[E040]Unexpected token after '$0'. Malformed For-loop
Note: A for-loop looks like
`for i := 0 to 10 do println i`

prog: FOR ID ASSIGN INT TO VAR
##
## Ends in an error in state: 82.
##
## expr -> FOR ID ASSIGN expr TO . expr DO expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO
##

[E041]Unexpected token after '$0'. Expecting an expression (upper-bound)
Note: A for-loop looks like
`for i := 0 to 10 do println i`
               ~^ (upper-bound)

prog: FOR ID ASSIGN INT TO INT VAR
##
## Ends in an error in state: 83.
##
## arith -> expr . PLUS expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## arith -> expr . MINUS expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## arith -> expr . TIMES expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## arith -> expr . DIVIDE expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . EQ expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . NEQ expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . GT expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . LT expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . GE expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . LE expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . AND expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . OR expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## expr -> FOR ID ASSIGN expr TO expr . DO expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO expr
##

[E042]Unexpected token after '$0'. Expecting DO.

prog: FOR ID ASSIGN INT TO INT DO VAR
##
## Ends in an error in state: 84.
##
## expr -> FOR ID ASSIGN expr TO expr DO . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO expr DO
##

[E043]Unexpected token after '$0'. Expecting an expression (loop-body)
Note: A for-loop looks like
`for i := 0 to 10 do println i`
                     ~~~~~~~~^ (loop body)

prog: FOR ID ASSIGN INT TO INT DO INT WHILE
##
## Ends in an error in state: 85.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## expr -> FOR ID ASSIGN expr TO expr DO expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO expr DO expr
##

[E044]Have parsed a for-loop 
  after '$0' 
but after which the program ended abruptly. Expecting expression

prog: ID LPAREN INT COMMA VAR
##
## Ends in an error in state: 75.
##
## exprc -> exprc COMMA . expr [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## exprc COMMA
##

[E045]Malformed tuple.
Note: A tuple looks like () (e) (e[,e])

prog: ID LPAREN INT COMMA INT VAR
##
## Ends in an error in state: 76.
##
## arith -> expr . PLUS expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . GT expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . LT expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . GE expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . LE expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . AND expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . OR expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## exprc -> exprc COMMA expr . [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## exprc COMMA expr
##

[E046]Malformed tuple. Unclosed LPAREN.
Note: A tuple looks like () (e) (e[,e])

prog: ID LPAREN INT VAR
##
## Ends in an error in state: 77.
##
## arith -> expr . PLUS expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . GT expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . LT expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . GE expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . LE expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . AND expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . OR expr [ TIMES RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## exprc -> expr . [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## expr
##

[E047]Unexpected token after '$0'.
Note: Expecting a RPAREN if a tuple is desired.

prog: ID LBRACK WHILE
##
## Ends in an error in state: 17.
##
## instOfRec -> ID LBRACK . tdefs RBRACK [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACK
##

[E048]Malformed record instantiation. Note that a record instance is one of the two:
  {}                  : an empty record
  {id = e[,id' = e']} : a record with fields id, id'...

prog: ID LBRACK ID WHILE
##
## Ends in an error in state: 18.
##
## tdefs -> ID . EQ expr [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

[E049]Malformed field assignment. Expecting EQ followed by expr (field-value).
Note: to assign a field with e
  {id = e[,id' = e']} : a record with fields id, id'...
        ^        ~^ (field-value)


prog: ID LBRACK ID EQ VAR
##
## Ends in an error in state: 19.
##
## tdefs -> ID EQ . expr [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ
##

[E050]Malformed field assignment. Expecting expr (field-value).
Note: to assign a field with e
  {id = e[,id' = e']} : a record with fields id, id'...
        ^        ~^ (field-value)


prog: ID LBRACK ID EQ INT VAR
##
## Ends in an error in state: 86.
##
## arith -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . LT expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . GE expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . LE expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## tdefs -> ID EQ expr . [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ expr
##

[E051]Malformed record instantiation. Expecting either more fields or RBRACK

prog: ID LBRACK COMMA WHILE
##
## Ends in an error in state: 89.
##
## tdefs -> tdefs COMMA . ID EQ expr [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## tdefs COMMA
##

[E052]Malformed record instantiation. Expecting either more fields or RBRACK

prog: ID LBRACK COMMA ID WHILE
##
## Ends in an error in state: 90.
##
## tdefs -> tdefs COMMA ID . EQ expr [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## tdefs COMMA ID
##

[E053]Malformed record instantiation. Expecting EQ.

prog: ID LBRACK COMMA ID EQ VAR
##
## Ends in an error in state: 91.
##
## tdefs -> tdefs COMMA ID EQ . expr [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## tdefs COMMA ID EQ
##

[E054]Malformed record instantiation. Expecting either more fields or RBRACK

prog: ID LBRACK COMMA ID EQ INT VAR
##
## Ends in an error in state: 92.
##
## arith -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . LT expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . GE expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . LE expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## compare -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE COMMA AND ]
## tdefs -> tdefs COMMA ID EQ expr . [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## tdefs COMMA ID EQ expr
##

[E055]Unexpected token after '$0', Expecting either more fields or RBRACK.

prog: ID LBRACE VAR
##
## Ends in an error in state: 93.
##
## instOfArr -> ID LBRACE . expr RBRACE OF expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## lvalue_ -> LBRACE . expr RBRACE lvalue_ [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACE
##

[E056]Unexpected token after '$0'. Malformed array instantiation.
Note: An array instantiation is
  `T [e1] of e2` where e1 is the number of elements
                       T  is the type within array
                       e2 is the initial value

prog: ID LBRACE INT VAR
##
## Ends in an error in state: 94.
##
## arith -> expr . PLUS expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . MINUS expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . TIMES expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . DIVIDE expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . EQ expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . NEQ expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . GT expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . LT expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . GE expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . LE expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . AND expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . OR expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## instOfArr -> ID LBRACE expr . RBRACE OF expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## lvalue_ -> LBRACE expr . RBRACE lvalue_ [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACE expr
##

[E057]Malformed array instantiation.
Note: An array instantiation is
  `T [e1] of e2` where e1 is the number of elements
                       T  is the type within array
                       e2 is the initial value

prog: ID LBRACE INT RBRACE WHILE
##
## Ends in an error in state: 95.
##
## instOfArr -> ID LBRACE expr RBRACE . OF expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## lvalue_ -> LBRACE expr RBRACE . lvalue_ [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACE expr RBRACE
##

[E058]Unexpected token after '$0', expecting OF.

prog: ID LBRACE INT RBRACE OF VAR
##
## Ends in an error in state: 96.
##
## instOfArr -> ID LBRACE expr RBRACE OF . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACE expr RBRACE OF
##

[E059]Unexpected token after '$0', expecting expression (initial-value)
  `T [e1] of e2`
             ~^ (initial-value)

prog: ID LBRACE INT RBRACE OF INT WHILE
##
## Ends in an error in state: 97.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## instOfArr -> ID LBRACE expr RBRACE OF expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACE expr RBRACE OF expr
##

[E060]Have parsed an array instantiation
$0
but after which the program ended abruptly. Expecting expressions

prog: ID DOT ID LBRACE VAR
##
## Ends in an error in state: 36.
##
## lvalue_ -> LBRACE . expr RBRACE lvalue_ [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

[E061]Unexpected token after '$0'.

prog: ID DOT ID LBRACE INT VAR
##
## Ends in an error in state: 37.
##
## arith -> expr . PLUS expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . MINUS expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . TIMES expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . DIVIDE expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . EQ expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . NEQ expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . GT expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . LT expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . GE expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . LE expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . AND expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . OR expr [ TIMES RBRACE PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## lvalue_ -> LBRACE expr . RBRACE lvalue_ [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## LBRACE expr
##

[E062]Unclosed RBRACE. Note that an array accessor is `e[e']`

prog: ID DOT ID LBRACE INT RBRACE WHILE
##
## Ends in an error in state: 43.
##
## lvalue_ -> LBRACE expr RBRACE . lvalue_ [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## LBRACE expr RBRACE
##

[E063]Unexpected token after '$0'.
Note: delete after '$0'

prog: ID DOT WHILE
##
## Ends in an error in state: 44.
##
## lvalue_ -> DOT . ID lvalue_ [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## DOT
##

[E064]Unexpected token after '$0'. Malformed record accessor.
Note that a record accessor is `id[.id]`

prog: ID DOT ID WHILE
##
## Ends in an error in state: 45.
##
## lvalue_ -> DOT ID . lvalue_ [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## DOT ID
##

[E065]Unexpected token after '$0'. Malformed record accessor.

prog: IF INT VAR
##
## Ends in an error in state: 98.
##
## arith -> expr . PLUS expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . MINUS expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . TIMES expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## arith -> expr . DIVIDE expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . EQ expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . NEQ expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . GT expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . LT expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . GE expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . LE expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . AND expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## compare -> expr . OR expr [ TIMES THEN PLUS OR NEQ MINUS LT LE GT GE EQ DIVIDE AND ]
## ite -> IF expr . THEN expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## ite -> IF expr . THEN expr ELSE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF expr
##

[E066]Unexpected token after '$0'. Expecting THEN.

prog: ID ID WHILE
##
## Ends in an error in state: 35.
##
## lvalue -> ID . lvalue_ [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID
##

[E067]Unexpected token after '$0'.

prog: IF INT THEN VAR
##
## Ends in an error in state: 99.
##
## ite -> IF expr THEN . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## ite -> IF expr THEN . expr ELSE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF expr THEN
##

[E068]Unexpected token after '$0'. Expecting expression (else-branch)
  `IF c THEN e1 ELSE e2`
                     ~^ (else-branch)

prog: IF INT THEN INT WHILE
##
## Ends in an error in state: 100.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## ite -> IF expr THEN expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## ite -> IF expr THEN expr . ELSE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF expr THEN expr
##

[E069]Unexpected token after '$0'.
Note: delete after '$0'.
Note: 
  `IF c THEN e`          : Unit (e has side effects)
  `IF c THEN e1 ELSE e2` : T iff e1, e2 : T

prog: IF INT THEN INT ELSE VAR
##
## Ends in an error in state: 101.
##
## ite -> IF expr THEN expr ELSE . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF expr THEN expr ELSE
##

[E070]Unexpected token after '$0'. Expecting expression (else-branch)
Note: 
  `IF c THEN e`          : Unit (e has side effects)
  `IF c THEN e1 ELSE e2` : T iff e1, e2 : T
                     ~^ (else-branch)


prog: IF INT THEN INT ELSE INT WHILE
##
## Ends in an error in state: 102.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## ite -> IF expr THEN expr ELSE expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF expr THEN expr ELSE expr
##

[E071]Unexpected token after '$0'.
Note: delete after '$0'.

prog: LET VAR ID COLON ID ASSIGN INT TO
##
## Ends in an error in state: 103.
##
## arith -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . LT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . GE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . LE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## vardec -> VAR ID COLON ID ASSIGN expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN expr
##

[E072]Unexpected token after '$0'. Expecting [VAR | TYPE | IN | FUNCTION] Malformed Letexp.
Note: delete after '$0'.

prog: LET VAR ID ASSIGN VAR
##
## Ends in an error in state: 104.
##
## vardec -> VAR ID ASSIGN . expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN
##

[E073]Variable binding ended abruptly. Expecting expression (variable-value)
  `var id := e`
             ^ (variable-value)

prog: LET VAR ID ASSIGN INT TO
##
## Ends in an error in state: 105.
##
## arith -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . LT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . GE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . LE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## vardec -> VAR ID ASSIGN expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN expr
##

[E074]Unexpected token after '$0'. Expecting [VAR | TYPE | IN | FUNCTION]. Malformed Letexp.

prog: LET TYPE WHILE
##
## Ends in an error in state: 106.
##
## tydec -> TYPE . ID EQ ID [ VAR TYPE IN FUNCTION ]
## tydec -> TYPE . ID EQ LBRACK tyfields RBRACK [ VAR TYPE IN FUNCTION ]
## tydec -> TYPE . ID EQ ARRAY OF ID [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## TYPE
##

[E075]Unexpected token after '$0', Malformed type declaration.
Note: replace after '$0' with an fresh type identifier


prog: LET TYPE ID WHILE
##
## Ends in an error in state: 107.
##
## tydec -> TYPE ID . EQ ID [ VAR TYPE IN FUNCTION ]
## tydec -> TYPE ID . EQ LBRACK tyfields RBRACK [ VAR TYPE IN FUNCTION ]
## tydec -> TYPE ID . EQ ARRAY OF ID [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## TYPE ID
##

[E076]Unexpected token after '$0', expecting EQ.


prog: LET TYPE ID EQ WHILE
##
## Ends in an error in state: 108.
##
## tydec -> TYPE ID EQ . ID [ VAR TYPE IN FUNCTION ]
## tydec -> TYPE ID EQ . LBRACK tyfields RBRACK [ VAR TYPE IN FUNCTION ]
## tydec -> TYPE ID EQ . ARRAY OF ID [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## TYPE ID EQ
##

[E077]Unexpected token after '$0'. Malformed type declaration.
Note: A type declaration is one of the three
  type id = id              -- type alias
  type id = {}              -- empty record
  type id = {id:T[,id':T']} -- record
  type id = Array of T      -- array

prog: LET TYPE ID EQ LBRACK WHILE
##
## Ends in an error in state: 109.
##
## tydec -> TYPE ID EQ LBRACK . tyfields RBRACK [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## TYPE ID EQ LBRACK
##

[E078]Unexpected token after '$0'. Expecting tyfields or RBRACK
Note: record decl is `type id = {id:T[,id':T']}`
                     `type id = {}`

prog: LET FUNCTION ID LPAREN ID WHILE
##
## Ends in an error in state: 110.
##
## tyfields -> ID . COLON ID [ RPAREN RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

[E079]Unexpected token after '$0'. Expecting COLON.
Note: record decl is `type id = {id:T[,id':T']}`
                     `type id = {}`

prog: LET FUNCTION ID LPAREN ID COLON WHILE
##
## Ends in an error in state: 111.
##
## tyfields -> ID COLON . ID [ RPAREN RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## ID COLON
##

[E080]Unexpected token after '$0'. Expecting ID (type-id)
Note: record decl is `type id = {}`
                     `type id = {id:T[,id':T']}`
                                    ^      ~^ (type-id)


prog: LET TYPE ID EQ LBRACK ID COLON ID WHILE
##
## Ends in an error in state: 113.
##
## tydec -> TYPE ID EQ LBRACK tyfields . RBRACK [ VAR TYPE IN FUNCTION ]
## tyfields -> tyfields . COMMA ID COLON ID [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## TYPE ID EQ LBRACK tyfields
##

[E081]Unexpected token after '$0'. Expecting either more tyfields or RBRACK
Note: record decl is `type id = {}`
                     `type id = {id:T[,id':T']}`

prog: LET FUNCTION ID LPAREN COMMA WHILE
##
## Ends in an error in state: 115.
##
## tyfields -> tyfields COMMA . ID COLON ID [ RPAREN RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## tyfields COMMA
##

[E082]Unexpected token after '$0'. Expecting more tyfields.

prog: LET FUNCTION ID LPAREN COMMA ID WHILE
##
## Ends in an error in state: 116.
##
## tyfields -> tyfields COMMA ID . COLON ID [ RPAREN RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## tyfields COMMA ID
##

[E083]Unexpected token after '$0'. Expecting COLON followed by ID (type-id)
Note: record decl is `type id = {id:T[,id':T']}`
                                          ~~^ (COLON type-id)


prog: LET FUNCTION ID LPAREN COMMA ID COLON WHILE
##
## Ends in an error in state: 117.
##
## tyfields -> tyfields COMMA ID COLON . ID [ RPAREN RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## tyfields COMMA ID COLON
##

[E084]Unexpected token after '$0'. Expecting ID (type-id)
Note: record decl is `type id = {id:T[,id':T']}`
                                    ^      ~^ (type-id)

prog: LET TYPE ID EQ ARRAY WHILE
##
## Ends in an error in state: 120.
##
## tydec -> TYPE ID EQ ARRAY . OF ID [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## TYPE ID EQ ARRAY
##

[E085]Unexpected token after '$0'. Expecting OF
Note: array decl is `type id = array of T`

prog: LET TYPE ID EQ ARRAY OF WHILE
##
## Ends in an error in state: 121.
##
## tydec -> TYPE ID EQ ARRAY OF . ID [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## TYPE ID EQ ARRAY OF
##

[E086]Unexpected token after '$0'. Expecting ID (type-id)
Note: array decl is `type id = array of T`
                                        ^ (type-id)

prog: LET IN VAR
##
## Ends in an error in state: 123.
##
## letexp -> LET decs IN . exprs END [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## LET decs IN
##

[E087]Unexpected token after '$0'. Expecting expressions.

prog: LET IN INT RPAREN
##
## Ends in an error in state: 124.
##
## exprs -> exprs . SEMICOLON expr [ SEMICOLON END ]
## letexp -> LET decs IN exprs . END [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## LET decs IN exprs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 128, spurious reduction of production exprs -> expr
##

[E088]Unexpected token after '$0'. Expecting END or more expressions delimited by SEMICOLON
  expr          -- single expression
  (expr[;expr]) -- a sequence of expression with the last as its value.

prog: LPAREN INT SEMICOLON VAR
##
## Ends in an error in state: 125.
##
## exprs -> exprs SEMICOLON . expr [ SEMICOLON RPAREN END ]
##
## The known suffix of the stack is as follows:
## exprs SEMICOLON
##

[E089]Unexpected token after '$0'.
Note: delete after '$0' or replace with expressions delimited by SEMICOLON

prog: LPAREN INT SEMICOLON INT VAR
##
## Ends in an error in state: 126.
##
## arith -> expr . PLUS expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## arith -> expr . MINUS expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## arith -> expr . TIMES expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## arith -> expr . DIVIDE expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . EQ expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . NEQ expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . GT expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . LT expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . GE expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . LE expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . AND expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . OR expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## exprs -> exprs SEMICOLON expr . [ SEMICOLON RPAREN END ]
##
## The known suffix of the stack is as follows:
## exprs SEMICOLON expr
##

[E090]Unexpected token after '$0'
Note: delete after '$0' or replace with expressions delimited by SEMICOLON

prog: LPAREN INT VAR
##
## Ends in an error in state: 128.
##
## arith -> expr . PLUS expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## arith -> expr . MINUS expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## arith -> expr . TIMES expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## arith -> expr . DIVIDE expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . EQ expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . NEQ expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . GT expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . LT expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . GE expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . LE expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . AND expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## compare -> expr . OR expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MINUS LT LE GT GE EQ END DIVIDE AND ]
## exprs -> expr . [ SEMICOLON RPAREN END ]
##
## The known suffix of the stack is as follows:
## expr
##

[E091]Unexpected token after '$0'
Note: delete after '$0'

prog: LET FUNCTION WHILE
##
## Ends in an error in state: 129.
##
## fundec -> FUNCTION . ID nonempty_list(ID) EQ expr [ VAR TYPE IN FUNCTION ]
## fundec -> FUNCTION . ID LPAREN tyfields RPAREN EQ expr [ VAR TYPE IN FUNCTION ]
## fundec -> FUNCTION . ID LPAREN tyfields RPAREN COLON ID EQ expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION
##

[E092]Unexpected token after '$0'. Expecting ID (function-id). 
Malformed function definition.
Note: function definition is one of the three
  `function id [id] = expr`                      -- juxtapositional with 
                                                    bidirectional inferred type
  `function id (id : T[,id' : T']) = expr`       -- inferred return type
  `function id (id : T[,id' : T']) : T'' = expr` -- explicit type annotation


prog: LET FUNCTION ID WHILE
##
## Ends in an error in state: 130.
##
## fundec -> FUNCTION ID . nonempty_list(ID) EQ expr [ VAR TYPE IN FUNCTION ]
## fundec -> FUNCTION ID . LPAREN tyfields RPAREN EQ expr [ VAR TYPE IN FUNCTION ]
## fundec -> FUNCTION ID . LPAREN tyfields RPAREN COLON ID EQ expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID
##

[E093]Unexpected token after '$0'. Expecting a list of arguments.
Note: arguments are declared in one of the three
  `function id [id] = expr`                      -- juxtapositional with 
                                                    bidirectional inferred type
  `function id (id : T[,id' : T']) = expr`       -- inferred return type
  `function id (id : T[,id' : T']) : T'' = expr` -- explicit type annotation
  

prog: LET FUNCTION ID LPAREN WHILE
##
## Ends in an error in state: 131.
##
## fundec -> FUNCTION ID LPAREN . tyfields RPAREN EQ expr [ VAR TYPE IN FUNCTION ]
## fundec -> FUNCTION ID LPAREN . tyfields RPAREN COLON ID EQ expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID LPAREN
##

[E094]Unexpected token after '$0'. Expecting [ID COLON ID] (arg-decl) or RPAREN


prog: LET FUNCTION ID LPAREN ID COLON ID WHILE
##
## Ends in an error in state: 132.
##
## fundec -> FUNCTION ID LPAREN tyfields . RPAREN EQ expr [ VAR TYPE IN FUNCTION ]
## fundec -> FUNCTION ID LPAREN tyfields . RPAREN COLON ID EQ expr [ VAR TYPE IN FUNCTION ]
## tyfields -> tyfields . COMMA ID COLON ID [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID LPAREN tyfields
##

[E095]Unexpected token after '$0'. Expecting more arg decl delimited by COMMA or RPAREN

prog: LET FUNCTION ID LPAREN RPAREN WHILE
##
## Ends in an error in state: 133.
##
## fundec -> FUNCTION ID LPAREN tyfields RPAREN . EQ expr [ VAR TYPE IN FUNCTION ]
## fundec -> FUNCTION ID LPAREN tyfields RPAREN . COLON ID EQ expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID LPAREN tyfields RPAREN
##

[E096]Unexpected token after '$0'. Expecting EQ or [COLON ID] (extype-anno)
  `function id (id : T[,id' : T']) = expr`       -- inferred return type
  `function id (id : T[,id' : T']) : T'' = expr` -- explicit type annotation
                                   ~~~~^ (extype-anno)


prog: LET FUNCTION ID LPAREN RPAREN EQ VAR
##
## Ends in an error in state: 134.
##
## fundec -> FUNCTION ID LPAREN tyfields RPAREN EQ . expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID LPAREN tyfields RPAREN EQ
##

[E097]Unexpected token after '$0'. Expecting expression (function-body)
  `function ... = expr`
                  ~~~^ (function-body)

prog: LET FUNCTION ID LPAREN RPAREN EQ INT TO
##
## Ends in an error in state: 135.
##
## arith -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . LT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . GE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . LE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## fundec -> FUNCTION ID LPAREN tyfields RPAREN EQ expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID LPAREN tyfields RPAREN EQ expr
##

[E098]Unexpected token after '$0'. Expecting [VAR | TYPE | IN | FUNCTION]

prog: LET FUNCTION ID LPAREN RPAREN COLON WHILE
##
## Ends in an error in state: 136.
##
## fundec -> FUNCTION ID LPAREN tyfields RPAREN COLON . ID EQ expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID LPAREN tyfields RPAREN COLON
##

[E099]Unexpected token after '$0'. Expecting ID (type-id).
Note: explicit return type annotation for function is
  `function id (id : T[,id' : T']) : T'' = expr`
                                   ~~~~^ (type-id)

prog: LET FUNCTION ID LPAREN RPAREN COLON ID WHILE
##
## Ends in an error in state: 137.
##
## fundec -> FUNCTION ID LPAREN tyfields RPAREN COLON ID . EQ expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID LPAREN tyfields RPAREN COLON ID
##

[E100]Unexpected token after '$0'. Expecting EQ.

prog: LET FUNCTION ID LPAREN RPAREN COLON ID EQ VAR
##
## Ends in an error in state: 138.
##
## fundec -> FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ . expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ
##

[E101]Unexpected token after '$0'. Expecting expression (function-body)
  `function ... = expr`
                  ~~~^ (function-body)

prog: LET FUNCTION ID LPAREN RPAREN COLON ID EQ INT TO
##
## Ends in an error in state: 139.
##
## arith -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . LT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . GE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . LE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## fundec -> FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ expr
##

[E102]Unexpected token after '$0'. Have parsed a function definition.
Expecting [VAR | TYPE | IN | FUNCTION]

prog: LPAREN INT END
##
## Ends in an error in state: 148.
##
## expr -> LPAREN exprs . RPAREN [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## exprs -> exprs . SEMICOLON expr [ SEMICOLON RPAREN ]
##
## The known suffix of the stack is as follows:
## LPAREN exprs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 128, spurious reduction of production exprs -> expr
##

[E103]Expecting RPAREN or more expressions delimited by SEMICOLON.
Note: valid expressions include
  ()            -- Unit
  expr          -- single expression
  (expr)        -- single expression
  (expr[;expr]) -- sequence of expressions

prog: WHILE INT VAR
##
## Ends in an error in state: 151.
##
## arith -> expr . PLUS expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## arith -> expr . MINUS expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## arith -> expr . TIMES expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## arith -> expr . DIVIDE expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . EQ expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . NEQ expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . GT expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . LT expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . GE expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . LE expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . AND expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## compare -> expr . OR expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ DO DIVIDE AND ]
## expr -> WHILE expr . DO expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr
##

[E104]Unexpected token after '$0'. Expecting DO. Malformed while-loop
Note: A while-loop has the form of
  `WHILE expr DO expr`

prog: WHILE INT DO VAR
##
## Ends in an error in state: 152.
##
## expr -> WHILE expr DO . expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO
##

[E105]Unexpected token after '$0'. Expecting expression (loop-body)
  `WHILE expr DO expr`
                 ~~~^ (loop-body)

prog: WHILE INT DO INT WHILE
##
## Ends in an error in state: 153.
##
## arith -> expr . PLUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . MINUS expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . TIMES expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . EQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . NEQ expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LT expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . GE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . LE expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . AND expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## compare -> expr . OR expr [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## expr -> WHILE expr DO expr . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO expr
##

[E106]Unexpected token after '$0'. Have parsed while-loop.
Note: delete after '$0'

prog: INT VAR
##
## Ends in an error in state: 155.
##
## arith -> expr . PLUS expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## arith -> expr . MINUS expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## arith -> expr . TIMES expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## arith -> expr . DIVIDE expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## compare -> expr . EQ expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## compare -> expr . NEQ expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## compare -> expr . GT expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## compare -> expr . LT expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## compare -> expr . GE expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## compare -> expr . LE expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## compare -> expr . AND expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## compare -> expr . OR expr [ TIMES PLUS OR NEQ MINUS LT LE GT GE EQ EOF DIVIDE AND ]
## prog -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##

[E107]Unexpected token after '$0'. Have parsed expr
Note: delete after '$0'

prog: ID INT WHILE
##
## Ends in an error in state: 33.
##
## expr -> funcall . [ VAR TYPE TO TIMES THEN SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
## funcall -> funcall . argvalue [ VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NIL NEQ MINUS LT LPAREN LE INT IN ID GT GE FUNCTION EQ EOF END ELSE DO DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## funcall
##

[E108]Unexpected token after '$0'. Have parsed funcall.
Note: funcall is one of the two
  lvalue argvalue  -- juxtapositional
  lvalue(argvalue) -- parenthesized
where argvalue is [INT | STRING | lvalue | NIL | (exprc)]

prog: LET FUNCTION ID ID WHILE
##
## Ends in an error in state: 140.
##
## nonempty_list(ID) -> ID . [ EQ ]
## nonempty_list(ID) -> ID . nonempty_list(ID) [ EQ ]
##
## The known suffix of the stack is as follows:
## ID
##

[E109]Unexpected token after '$0'. Expecting more arguments or EQ.
  `function id [id] = expr`

prog: LET FUNCTION ID ID EQ VAR
##
## Ends in an error in state: 143.
##
## fundec -> FUNCTION ID nonempty_list(ID) EQ . expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID nonempty_list(ID) EQ
##

[E110]function definition ended abruptly.
Note: A valid letexp with a fundec looks like
  `function id x = x`

prog: LET FUNCTION ID ID EQ ID TO
##
## Ends in an error in state: 144.
##
## arith -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## arith -> expr . DIVIDE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . LT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . GE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . LE expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## compare -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS LT LE IN GT GE FUNCTION EQ DIVIDE AND ]
## fundec -> FUNCTION ID nonempty_list(ID) EQ expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION ID nonempty_list(ID) EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production lvalue_ ->
## In state 70, spurious reduction of production lvalue -> ID lvalue_
## In state 24, spurious reduction of production expr -> lvalue
##

[E110]Let-expression ended abruptly. Expecting more declarations or IN followed by expression.
Note: A valid letexp looks like
  `let function id x = x in id 1 end`
